#pragma once
#include <cmath>   // for std::sqrt from ChatGPT for the isPrime function
namespace mathlib {
	template<typename type>
	class Fraction {
	private:
		type numerator = 1;
		type denominator = 1;

		/*bool isTypeFloat() {
			if (typeid(type) == typeid(float)) {
				return true;
			}
			else {
				return false;
			}
		};*/
		
		float findGCD(type a, type b) {
			
			while (b != 0){
				float temp = b;
					b = a % b;
					a = temp;
			}
			return a;
		}
		float helpSimplify(float number) {
			number = abs(number);
			while (number > 0) {
				number -= 1;
			}
			number += 1;//got just the decimal part
			return 1 / number;
		}
		//Method generated by ChatGPT 4/23/2025
		//modified to prevent simpliying already simple fractions
		bool isSimple(int n) {
			n = abs(n); // Ensure n is positive
			if (n <= 1)        return true;            // 0 and 1 are not prime
			if (n <= 3)        return true;             // 2 and 3 are prime
			if (n % 2 == 0)    return false;            // exclude even numbers >2

			int limit = static_cast<int>(std::sqrt(n));
			for (int d = 3; d <= limit; d += 2) {
				if (n % d == 0)
					return false;
			}
			return true;
		}
		//end of generated method
	public:
		Fraction<type> simplify() {
			if (typeid(numerator) == typeid(float) || typeid(denominator) == typeid(float)) {
				return *this;//cant do floats
			}
			
			//if (isSimple(numerator) || isSimple(denominator)) {
			//	return *this;//already simplified
			//}
			Fraction<float> tempFraction;
			type gcdNum1;
			type gcdNum2;
			if (numerator < 0) {//can't use abs() for some reason
				gcdNum1 = -1 * numerator;
			}
			else {
				gcdNum1 = numerator;
			}
			if (denominator < 0) {
				gcdNum2 = -1 * denominator;
			}
			else {
				gcdNum2 = denominator;
			}
			float gcd = findGCD(gcdNum1, gcdNum2);
			tempFraction.setNumerator(numerator / gcd);
			tempFraction.setDenominator(denominator / gcd);
			if (tempFraction.getDenominator() < 0) {
				tempFraction.setNumerator(-1*tempFraction.getNumerator());
				tempFraction.setDenominator(-1*tempFraction.getDenominator());
			};//reacllocate the negative sign
			if (isSimple(tempFraction.getNumerator()) || isSimple(tempFraction.getDenominator())) {
				type returnNumerator = (type)tempFraction.getNumerator();
				type returnDenominator = (type)tempFraction.getDenominator();
				Fraction<type> returnFraction(returnNumerator, returnDenominator);
				return returnFraction;//if the fraction is already simple(after the division, return it
			}
			bool isNumeratorTypeFloat = (typeid(tempFraction.getNumerator()) == typeid(float));
			bool isDenominatorTypeFloat = (typeid(tempFraction.getDenominator()) == typeid(float));
			for (short i = 0; i < 1;i++) {
				if (isNumeratorTypeFloat) {
					float adjustValue = helpSimplify(tempFraction.getNumerator());
					tempFraction.setNumerator(tempFraction.getNumerator() * adjustValue);
					tempFraction.setDenominator(tempFraction.getDenominator() * adjustValue);

				};
				if (isDenominatorTypeFloat) {
					float adjustValue = helpSimplify(tempFraction.getDenominator());
					tempFraction.setNumerator(tempFraction.getNumerator() * adjustValue);
					tempFraction.setDenominator(tempFraction.getDenominator() * adjustValue);

				};
			};
			//*this = resultFraction;
			//Fraction<type> A((type)tempFraction.getNumerator,(type)tempFraction.getDenominator);
			type returnNumerator = (type)tempFraction.getNumerator();
			type returnDenominator = (type)tempFraction.getDenominator();
			Fraction<type> returnFraction(returnNumerator, returnDenominator);

			return returnFraction;
		};
		Fraction() = default;
		Fraction<type> simplify(Fraction<type> input) {
			return input.simplify;
		};
		Fraction(type inputNumerator, type inputDenominator) {
			numerator = inputNumerator;
			if (!setDenominator(inputDenominator)) {
				denominator = 1;
				std::cout << "Denominator cannot be 0, set to 1" << std::endl;
			}
		}
		Fraction<type> operator + (const Fraction<type>& input) const {
			//frac 1 num(frax2 denum) + frac2 num(frax1 denum)
			if (this->denominator != input.denominator){
				type resultNumerator = this->numerator * input.denominator +
				input.numerator * this->denominator;
			type resultDenominator = this->denominator * input.denominator;
			Fraction<type> tempFraction(resultNumerator, resultDenominator);
			return tempFraction;
			} else {
				type resultNumerator = this->numerator + input.numerator;
				type resultDenominator = this->denominator;
				Fraction<type> tempFraction(resultNumerator, resultDenominator);
				return tempFraction;
			}

		}
		Fraction<type> operator - (const Fraction<type>& input) const {
			//frac 1 num(frax2 denum) + frac2 num(frax1 denum)
			if (this->denominator != input.denominator){
				type resultNumerator = this->numerator * input.denominator -
				input.numerator * this->denominator;
			type resultDenominator = this->denominator * input.denominator;
			Fraction<type> tempFraction(resultNumerator, resultDenominator);
			return tempFraction;
			} else {
				type resultNumerator = this->numerator - input.numerator;
				type resultDenominator = this->denominator;
				Fraction<type> tempFraction(resultNumerator, resultDenominator);
				return tempFraction;
			}

		}
		Fraction<type> operator / (const Fraction<type>& input) const {
			type resultNumerator = this->numerator * input.denominator;
			type resultDenominator = this->denominator * input.numerator;
			
			Fraction<type> tempFraction(resultNumerator, resultDenominator);
			return tempFraction;

		}
		Fraction<type> operator * (const Fraction<type>& input) const {
			type resultNumerator = this->numerator * input.numerator;
			type resultDenominator = this->denominator * input.denominator;

			Fraction<type> tempFraction(resultNumerator, resultDenominator);
			return tempFraction;

		}
		friend std::ostream& operator << (std::ostream& ostream, const Fraction<type>& fraction) {
			ostream << fraction.numerator << "/" << fraction.denominator;
			return ostream;
		}
		friend std::istream& operator >> (std::istream& istream,  Fraction<type>& fraction) {
			istream >> fraction.numerator;
			istream >> fraction.denominator;
			return istream;
		}
		float toFloat() const {
			return static_cast<float>(numerator) / static_cast<float>(denominator);
		}
		bool operator == (const Fraction<type>& input) const {
			if (this->numerator == input.numerator && this->denominator == input.denominator) {
				return true;
			}
			else {
				return false;
			}
		}
		bool operator != (const Fraction<type>& input) const {
			return !(*this == input);
		}
		bool operator < (const Fraction<type>& input) const {
			return this->toFloat() < input.toFloat();
		}
		bool operator > (const Fraction<type>& input) const {
			return this->toFloat() > input.toFloat();
		}
		bool operator <= (const Fraction<type>& input) const {
			return this->toFloat() <= input.toFloat();
		}
		bool operator >= (const Fraction<type>& input) const {
			return this->toFloat() >= input.toFloat();
		}


		type getNumerator() const { return numerator; }
		type getDenominator() const { return denominator;}
		type setNumerator(type inputNumerator) {
			numerator = inputNumerator;
			return numerator;
		};
		bool setDenominator(type inputDenominator) {
			denominator = inputDenominator;
			if (!inputDenominator) {
				denominator = 1;
				return false;//false if it is 0
			}
			else {
				return true;//was set correctly
			};
			return true;
		};
	};
	using unsignedFraction = Fraction<unsigned int>;
	using signedFraction = Fraction<int>;
	using floatFraction = Fraction<float>;
}